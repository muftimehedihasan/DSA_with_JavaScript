//CHAPTER 8
/* রিকার্শন পরিচিতি */
//-----------------

// রিকার্শন একটি ধারণা যেখানে একটি জিনিস নিজেকে সংজ্ঞায়িত করার জন্য ব্যবহৃত হয়। গণিত, ভাষাবিজ্ঞান এবং শিল্পে এটি প্রচলিত। কম্পিউটার বিজ্ঞানে, রিকার্সিভ ফাংশন হলো এমন একটি ফাংশন যা নিজেকে কল করে। রিকার্শন কমপ্লেক্স সমস্যাগুলি সমাধান করতে সাহায্য করে "divide-and-conquer" পদ্ধতি ব্যবহার করে। অনেক ডেটা স্ট্রাকচারের বাস্তবায়নে রিকার্শন দেখা যায়।

// রিকার্শনের নিয়মাবলী
// রিকার্শন সঠিকভাবে প্রয়োগ করা না হলে প্রোগ্রাম চিরতরে চলতে থাকবে এবং বন্ধ হবে না, যার ফলে স্ট্যাক ওভারফ্লো ঘটতে পারে। স্ট্যাক ওভারফ্লো তখন ঘটে যখন প্রোগ্রামের কল স্ট্যাকের সংখ্যা সীমিত মেমরি স্পেস অতিক্রম করে।

// বেস কেস
// প্রতিটি রিকার্সিভ ফাংশনে একটি বেস কেস থাকতে হবে। বেস কেস ফাংশনটির সমাপ্তির শর্ত নির্ধারণ করে। উদাহরণস্বরূপ, নিচের ফাংশনটি একটি সংখ্যা n থেকে ০ পর্যন্ত কাউন্টডাউন প্রিন্ট করে।
// function countDownToZero(n) {
//   if (n < 0) {
//     return;
//   } else {
//     console.log(n);
//     countDownToZero(n - 1);
//   }
// }
// countDownToZero(12);
// এখানে বেস কেস হলো যখন n ০ এর সমান বা কম হয়, তখন ফাংশনটি বন্ধ হবে।

// ডিভাইড-এন্ড-কনকোয়ার পদ্ধতি
// "Divide-and-conquer" পদ্ধতিতে, একটি সমস্যা তার ছোট ছোট অংশে বিভক্ত করা হয় এবং সেগুলি সমাধান করা হয়। উদাহরণস্বরূপ, ২ থেকে কাউন্টডাউন করা মানে ২ প্রিন্ট করা এবং তারপর ১ থেকে কাউন্টডাউন করা।

// ক্লাসিক উদাহরণ: ফিবোনাচ্চি সিকোয়েন্স
// ফিবোনাচ্চি সিকোয়েন্স হলো এক ক্রম, যেখানে প্রতিটি সংখ্যা তার আগের দুটি সংখ্যার যোগফল। উদাহরণস্বরূপ, 1, 1, 2, 3, 5, 8, 13, ইত্যাদি।

// পুনরাবৃত্তিমূলক সমাধান: ফিবোনাচ্চি সিকোয়েন্স
// function getNthFibo(n, memo = {}) {
//   // Base case: return n for n <= 1
//   if (n <= 1) {
//     return n;
//   }
  
//   // Check if value is already in memo
//   if (memo[n]) {
//     return memo[n];
//   }

//   // Recursively calculate and store the value in memo
//   memo[n] = getNthFibo(n - 1, memo) + getNthFibo(n - 2, memo);
  
//   return memo[n];
// }

// console.log(getNthFibo(20));

// function getNthFibo(n) {
//   if (n <= 1) {
//     return n;
//   }
//   return getNthFibo(n - 1) + getNthFibo(n - 2);
// }
// এই ফাংশনটি পুনরাবৃত্তি পদ্ধতিতে ফিবোনাচ্চি সংখ্যা বের করে। এর বেস কেস হলো যখন n ≤ 1।

// টেল রিকার্শন: ফিবোনাচ্চি সিকোয়েন্স
// টেল রিকার্শন তখন ঘটে যখন রিকার্সিভ কলটি ফাংশনের শেষ কাজ হয়। উদাহরণস্বরূপ:

// function getNthFiboBetter(n, lastlast, last) {
//   if (n == 0) {
//     return lastlast;
//   }
//   if (n == 1) {
//     return last;
//   }
//   return getNthFiboBetter(n-1, last, lastlast + last);
// }

// এই ফাংশনটির সময় জটিলতা O(n) এবং স্পেস জটিলতা O(n)।

// পাস্কালের ত্রিভুজ
// পাস্কালের ত্রিভুজ হলো একটি ত্রিভুজ যেখানে প্রতিটি উপাদান তার উপরের দুটি উপাদানের যোগফল। উদাহরণস্বরূপ, নিচের ফাংশনটি পাস্কালের ত্রিভুজের একটি টার্ম গণনা করে:

// function pascalTriangle(row, col) {
//   if (col == 0) {
//     return 1;
//   } else if (row == 0) {
//     return 0;
//   } else {
//     return pascalTriangle(row - 1, col) + pascalTriangle(row - 1, col - 1);
//   }
// }

// বিগ-ও বিশ্লেষণ
// রিকার্সিভ অ্যালগরিদমের সময় জটিলতা বিশ্লেষণ করতে রিকারেন্স রিলেশন ব্যবহার করা হয়। উদাহরণস্বরূপ, ফিবোনাচ্চি ফাংশনের রিকারেন্স রিলেশন হলো T(n) = T(n − 1) + T(n − 2) + O(1), যা সময় জটিলতা O(2^n) নির্দেশ করে।

// মাস্টার থিওরেম
// মাস্টার থিওরেম ব্যবহার করে রিকারেন্স রিলেশনের জটিলতা বিশ্লেষণ করা হয়। উদাহরণস্বরূপ, T(n) = aT(n/b) + O(n^c), এর তিনটি কেস রয়েছে:

// 1. যদি c < log_b(a), তবে T(n) = O(n^log_b(a))
// 2. যদি c = log_b(a), তবে T(n) = O(n^c log n)
// 3. যদি c > log_b(a), তবে T(n) = O(n^c)

// রিকার্সিভ কল স্ট্যাক মেমরি
// প্রতিটি রিকার্সিভ কল মেমরি নেয়, এবং এটি স্পেস জটিলতায় প্রভাব ফেলে। উদাহরণস্বরূপ, নিচের ফাংশনটি n বার মেমরি ব্যবহার করে:
// function printNRecursive(n) {
//   console.log(n);
//   if (n > 1){
//     printNRecursive(n-1);
//   }
// }
// printNRecursive(10);

// সারসংক্ষেপ
// রিকার্শন একটি শক্তিশালী টুল যা দুটি অংশ নিয়ে গঠিত: বেস কেস এবং ডিভাইড-এন্ড-কনকোয়ার পদ্ধতি।