// Chapter 12: Stacks and Queues
// এই অধ্যায়ে আমরা স্ট্যাক (Stack) এবং কিউ (Queue) নিয়ে আলোচনা করব। এই দুটি ডেটা স্ট্রাকচার খুবই সাধারণ কিন্তু শক্তিশালী ডেটা স্ট্রাকচার যা অন্যান্য জটিল ডেটা স্ট্রাকচার তৈরির জন্য ব্যবহার করা হয়। এখানে আমরা শিখব কিভাবে স্ট্যাক এবং কিউ কাজ করে, কখন এবং কিভাবে এই ডেটা স্ট্রাকচারগুলো ব্যবহার করতে হয়। এছাড়াও, বিভিন্ন উদাহরণ ও অনুশীলনের মাধ্যমে কিভাবে স্ট্যাক এবং কিউ অ্যাপ্লিকেশন সমস্যায় প্রয়োগ করা যায়, তা নিয়ে আলোচনা করা হবে।

// স্ট্যাক (Stack)
// স্ট্যাক এমন একটি ডেটা স্ট্রাকচার যেখানে সর্বশেষ যোগ করা উপাদানটি প্রথমে সরানো যায় এবং ব্যবহার করা যায়। এই কৌশলকে "Last In, First Out" (LIFO) বলা হয়। উদাহরণ হিসেবে, একটি প্লেটের স্তূপ কল্পনা করুন। নিচের প্লেটটি পেতে হলে, আপনাকে উপরের সব প্লেট সরাতে হবে। স্ট্যাকের একটি সুবিধা হলো এর দ্রুততা। কারণ আপনি সর্বশেষ উপাদানটি সরাবেন, তাই ডেটা খুঁজে পাওয়া এবং যোগ করা খুব দ্রুত, যা O(1) সময়ে করা যায়।

// স্ট্যাক ইমপ্লিমেন্টেশন
// জাভাস্ক্রিপ্টে স্ট্যাক ইমপ্লিমেন্ট করা যায় পপ (pop) এবং পুশ (push) ফাংশনের মাধ্যমে। স্ট্যাকের সবচেয়ে সহজ ইমপ্লিমেন্টেশন দেওয়া হলো:
// function Stack(array) {
//     this.array = [];
//     if (array) this.array = array;
// }

// Stack.prototype.getBuffer = function() {
//     return this.array.slice();
// }

// Stack.prototype.isEmpty = function() {
//     return this.array.length == 0;
// }

// পিক (Peek)
// স্ট্যাকের সর্বশেষ যোগ করা উপাদানটি দেখতে হলে আমরা পিক (peek) ফাংশন ব্যবহার করতে পারি। এটি উপাদানটি সরিয়ে নেয় না, শুধুমাত্র দেখায়।
// Stack.prototype.peek = function() {
//     return this.array[this.array.length - 1];
// }

// ইনসার্ট (Insertion)
// স্ট্যাকে নতুন উপাদান যোগ করতে পুশ (push) ফাংশন ব্যবহার করা হয়। এটি O(1) সময়ে সম্পন্ন হয়।
// Stack.prototype.push = function(value) {
//     this.array.push(value);
// }

// ডিলিট (Deletion)
// স্ট্যাক থেকে উপাদান সরাতে পপ (pop) ফাংশন ব্যবহার করা হয়, যা O(1) সময়ে করা হয়।
// Stack.prototype.pop = function() {
//     return this.array.pop();
// }

// অনুসন্ধান (Search)
// স্ট্যাকে নির্দিষ্ট একটি উপাদান খুঁজতে হলে একটি কপি স্ট্যাক ব্যবহার করতে হয় যাতে মূল স্ট্যাক পরিবর্তিত না হয়। অনুসন্ধান সময় লাগে O(n)।
// function stackSearch(stack, element) {
//     var bufferArray = stack.getBuffer();
//     var bufferStack = new Stack(bufferArray);

//     while (!bufferStack.isEmpty()) {
//         if (bufferStack.pop() == element) {
//             return true;
//         }
//     }
//     return false;
// }


// কিউ (Queue)
// -----------
// কিউ এমন একটি ডেটা স্ট্রাকচার যেখানে প্রথমে যোগ করা উপাদানটি প্রথমে সরানো যায়। একে "First In, First Out" (FIFO) বলা হয়। কিউর সুবিধা হলো এর দ্রুততা, যেমন ইনসার্ট এবং ডিলিট অপারেশনগুলি O(1) সময়ে সম্পন্ন হয়।

// কিউ ইমপ্লিমেন্টেশন
// জাভাস্ক্রিপ্টে কিউ ইমপ্লিমেন্ট করা যায় shift() এবং push() ফাংশনের মাধ্যমে। কিউর সহজ ইমপ্লিমেন্টেশন:
// function Queue(array) {
//     this.array = [];
//     if (array) this.array = array;
// }

// Queue.prototype.getBuffer = function() {
//     return this.array.slice();
// }

// Queue.prototype.isEmpty = function() {
//     return this.array.length == 0;
// }

// পিক (Peek)
// কিউতে প্রথম উপাদান দেখতে হলে পিক (peek) ফাংশন ব্যবহার করা হয়। এটি প্রথম উপাদানটি সরিয়ে নেয় না, শুধু দেখায়।
// Queue.prototype.peek = function() {
//     return this.array[0];
// }

// ইনসার্ট (Insertion)
// কিউতে উপাদান যোগ করতে enqueue() ফাংশন ব্যবহার করা হয়। এটি O(1) সময়ে করা হয়।
// Queue.prototype.enqueue = function(value) {
//     return this.array.push(value);
// }

// ডিলিট (Deletion)
// কিউ থেকে উপাদান সরাতে dequeue() ফাংশন ব্যবহার করা হয়, যা O(n) সময়ে সম্পন্ন হয়।
// Queue.prototype.dequeue = function() {
//     return this.array.shift();
// }

// উপসংহার

// স্ট্যাক এবং কিউ উভয়ই দ্রুত অপারেশন সমর্থন করে, কিন্তু তাদের ব্যবহারের ধরন আলাদা। স্ট্যাক LIFO পদ্ধতিতে কাজ করে এবং কিউ FIFO পদ্ধতিতে।

// স্ট্যাক বনাম কিউ এর পারফরম্যান্স
// স্ট্যাক এবং কিউ হল দুটি সাধারণ ডেটা স্ট্রাকচার, তবে এদের মধ্যে এলিমেন্ট ঢোকানো এবং সরানোর পদ্ধতিতে পার্থক্য রয়েছে। এই পার্থক্যগুলো নির্দিষ্ট অপারেশনে পারফরম্যান্সে প্রভাব ফেলে। আসুন দেখি স্ট্যাক এবং কিউ এর পারফরম্যান্স বিভিন্ন অপারেশনে কেমন হয়:

// ১. এলিমেন্ট যোগ করা (Push/Enqueue)
// স্ট্যাক (Push):
// * স্ট্যাকের ক্ষেত্রে সর্বশেষ ঢোকানো এলিমেন্টটি প্রথমে সরানো হয়, যা LIFO (Last In, First Out) নীতির ওপর ভিত্তি করে।
// * সময় জটিলতা: O(1) কারণ এলিমেন্টটি সরাসরি স্ট্যাকের উপরে যোগ করা হয়।

// কিউ (Enqueue):
// * কিউতে প্রথমে ঢোকানো এলিমেন্টটি প্রথমে সরানো হয়, যা FIFO (First In, First Out) নীতির ওপর ভিত্তি করে।
// * সময় জটিলতা: O(1), কারণ এলিমেন্টটি সরাসরি কিউ এর শেষে যোগ করা হয়।

// ২. এলিমেন্ট সরানো (Pop/Dequeue)
// স্ট্যাক (Pop):
// * স্ট্যাকের ক্ষেত্রে সর্বশেষ ঢোকানো এলিমেন্টটি সরানো হয়।
// * সময় জটিলতা: O(1), কারণ সর্বশেষ এলিমেন্টটি সরাসরি সরানো যায়।

// কিউ (Dequeue):
// * কিউতে প্রথমে ঢোকানো এলিমেন্টটি সরানো হয়।
// সময় জটিলতা:
// O(1), যদি লিঙ্কড লিস্ট দিয়ে কিউ তৈরি করা হয় (কারণ সরাসরি প্রথম এলিমেন্টটি সরানো যায়)।
// O(n), যদি সাধারণ অ্যারে-বেসড কিউ হয় (এক্ষেত্রে প্রথম এলিমেন্ট সরাতে অন্য সব এলিমেন্টগুলিকে এক ধাপ করে সরাতে হয়)।

// ৩. এলিমেন্ট অ্যাক্সেস করা
// স্ট্যাক:
// * আপনি শুধু স্ট্যাকের উপরের এলিমেন্টটি দেখতে পারবেন পিক (peek) অপারেশন দিয়ে।
// * সময় জটিলতা: O(1)।

// কিউ:
// * আপনি শুধু কিউ এর প্রথম এলিমেন্টটি দেখতে পারবেন পিক (peek) অপারেশন দিয়ে।
// * সময় জটিলতা: O(1)।

// ৪. সার্চ করা
// স্ট্যাক:
// * সার্চ করতে হলে একে একে পপ করতে হয় যতক্ষণ না কাঙ্ক্ষিত এলিমেন্ট পাওয়া যায়।
// * সময় জটিলতা: O(n), যেখানে n হল এলিমেন্টের সংখ্যা।

// কিউ:
// * সার্চ করতে হলে একে একে ডিকিউ করতে হয় যতক্ষণ না কাঙ্ক্ষিত এলিমেন্ট পাওয়া যায়।
// * সময় জটিলতা: O(n)।

// কখন স্ট্যাক এবং কিউ ব্যবহার করবেন:
// * স্ট্যাক ব্যবহার করবেন যদি এলিমেন্টগুলি LIFO অর্ডারে ম্যানেজ করতে হয়, যেমন:
    // * ফাংশন কল ম্যানেজমেন্ট (রিকার্শন বা পুনরাবৃত্তি)।
    // * টেক্সট এডিটরে আন্ডো ফাংশন।
    // * সিনট্যাক্স বিশ্লেষণ (ম্যাচিং ব্র্যাকেট)।

// * কিউ ব্যবহার করবেন যদি এলিমেন্টগুলি FIFO অর্ডারে ম্যানেজ করতে হয়, যেমন:
    // * অর্ডার প্রসেসিং (যেমন গ্রাহকদের সার্ভ করা)।
    // * গ্রাফ বা ট্রির BFS (Breadth-First Search)।
    // * টাস্ক শিডিউলিং।

// পারফরম্যান্স তুলনা:
// * স্ট্যাক সাধারণত অ্যারে ভিত্তিক ইমপ্লিমেন্টেশনে দ্রুততর হয় কারণ এতে ইনসার্ট এবং ডিলিট অপারেশন দুটিই O(1) সময়ে করা যায়।
// * কিউ কিছুটা ধীর হয় অ্যারে ভিত্তিক ইমপ্লিমেন্টেশনে (যেখানে ডিলিট অপারেশন O(n) সময় নেয়), তবে লিঙ্কড লিস্ট দিয়ে কিউ তৈরি করলে এটি স্ট্যাকের মতোই কার্যকর হয়।

// স্ট্যাক বনাম কিউ ব্যবহারের সমস্যা
// স্ট্যাক এবং কিউ উভয়েরই নির্দিষ্ট ক্ষেত্রে সমস্যা রয়েছে। কোন ডেটা স্ট্রাকচারটি কোন ক্ষেত্রে ব্যবহার করবেন, তা নির্ভর করে অ্যাপ্লিকেশন এবং প্রয়োজনের উপর। নিচে স্ট্যাক এবং কিউ ব্যবহারের কিছু সাধারণ সমস্যা নিয়ে আলোচনা করা হলো:

// ১. স্ট্যাকের সমস্যা
// a. সীমাবদ্ধতা (Fixed Size in Static Implementations)
// * সমস্যা: স্ট্যাক যদি স্ট্যাটিক (অ্যারে ভিত্তিক) ইমপ্লিমেন্টেশনের মাধ্যমে তৈরি হয়, তাহলে এর একটি নির্দিষ্ট সাইজ থাকে। যখন স্ট্যাক পূর্ণ হয়ে যায়, তখন আর নতুন এলিমেন্ট যোগ করা সম্ভব নয়। এই পরিস্থিতি স্ট্যাক ওভারফ্লো নামে পরিচিত।
// * পরামর্শ: ডাইনামিক ইমপ্লিমেন্টেশন (যেমন লিঙ্কড লিস্ট) ব্যবহার করলে সাইজের এই সীমাবদ্ধতা দূর করা যায়।

// b. এলিমেন্ট অ্যাক্সেসের সীমাবদ্ধতা
// * সমস্যা: স্ট্যাকের কেবল উপরের (Top) এলিমেন্টটি অ্যাক্সেস করা যায়। স্ট্যাকের মধ্যে থাকা মাঝের বা নীচের কোনো এলিমেন্ট সরাসরি অ্যাক্সেস করা যায় না। মাঝের বা অন্যান্য এলিমেন্ট পেতে হলে উপরের এলিমেন্টগুলো একে একে সরাতে হয়।
// * পরামর্শ: যেখানে এলিমেন্টের র‍্যান্ডম অ্যাক্সেস প্রয়োজন, সেখানে স্ট্যাক ব্যবহার করা বুদ্ধিমানের কাজ নয়।

// পরামর্শ: যেখানে এলিমেন্টের র‍্যান্ডম অ্যাক্সেস প্রয়োজন, সেখানে স্ট্যাক ব্যবহার করা বুদ্ধিমানের কাজ নয়।
// * সমস্যা: স্ট্যাকের মধ্যে খুব বেশি রিকার্শন (Recursion) থাকলে মেমরি দ্রুত পূর্ণ হয়ে যেতে পারে, বিশেষ করে ডিপ রিকার্শনের ক্ষেত্রে। এটি স্ট্যাক ওভারফ্লোর কারণ হতে পারে।
// * পরামর্শ: ইটারেশন (Iteration) ব্যবহার করে রিকার্শন এড়ানো যেতে পারে।

// ২. কিউ এর সমস্যা
// a. সীমাবদ্ধতা (Fixed Size in Array-based Queue)
// * সমস্যা: অ্যারে ভিত্তিক কিউতে নির্দিষ্ট সাইজ থাকে। যদি কিউ পূর্ণ হয়ে যায়, নতুন এলিমেন্ট যোগ করা সম্ভব হয় না, এটি কিউ ওভারফ্লো সমস্যা।
// *পরামর্শ: লিঙ্কড লিস্ট ভিত্তিক কিউ ইমপ্লিমেন্টেশন ব্যবহার করলে এই সমস্যাটি এড়ানো যায়।

// b. এলিমেন্ট সরানোর জটিলতা
// * সমস্যা: সাধারণ অ্যারে ভিত্তিক কিউতে প্রতিবার ডিকিউ (Dequeue) অপারেশনের পর বাকি এলিমেন্টগুলোকে এক ধাপ করে সরাতে হয়। এর ফলে এলিমেন্ট সরানোর সময় জটিলতা O(n) হয়।
// * পরামর্শ: এই সমস্যা এড়াতে সার্কুলার কিউ ব্যবহার করা যেতে পারে, যেখানে ইনডেক্স ম্যানেজমেন্ট ব্যবহার করে এলিমেন্ট সরানোর সময় খরচ কমানো হয়।

// c. এলিমেন্ট সার্চের সীমাবদ্ধতা
// * সমস্যা: কিউতে শুধুমাত্র প্রথম (ফ্রন্ট) এলিমেন্টটি সরাসরি অ্যাক্সেস করা যায়। মাঝখানের কোনো এলিমেন্ট সরাসরি দেখতে চাইলে একে একে এলিমেন্টগুলো সরাতে হয়, যা সময়সাপেক্ষ এবং অপ্রয়োজনীয় মেমরি ব্যবহার করতে পারে।
// * পরামর্শ: যেখানে এলিমেন্টের র‍্যান্ডম অ্যাক্সেস প্রয়োজন, সেখানে কিউ ব্যবহার করা ঠিক নয়।

// d. অপ্রয়োজনীয় মেমরি ব্যবহার
// * সমস্যা: লিঙ্কড লিস্ট ভিত্তিক কিউতে অতিরিক্ত পয়েন্টার মেমরি প্রয়োজন, যা ছোট অ্যাপ্লিকেশনের জন্য অপ্রয়োজনীয় মেমরি খরচের কারণ হতে পারে।
// * পরামর্শ: ছোট মেমরিতে অ্যারে ভিত্তিক কিউ বেশি কার্যকর হতে পারে।

// যখন স্ট্যাক এবং কিউ সমাধান নয়
// * র‍্যান্ডম অ্যাক্সেস প্রয়োজন: স্ট্যাক এবং কিউ উভয়েই র‍্যান্ডম অ্যাক্সেসের সুবিধা দেয় না। যদি ডেটার মধ্যে র‍্যান্ডমভাবে চলাচল বা অ্যাক্সেসের প্রয়োজন হয়, তাহলে অ্যারে, লিংকড লিস্ট বা হ্যাশম্যাপ এর মতো ডেটা স্ট্রাকচার ব্যবহার করা উচিত।
// * রেকর্ডিং বা ট্র্যাকিং প্রয়োজন: যদি আপনাকে এলিমেন্টগুলির পূর্ববর্তী অবস্থান ট্র্যাক করতে হয় বা মিডিয়া অ্যাক্সেস করতে হয়, তাহলে স্ট্যাক এবং কিউ কার্যকর নয়।

// সারসংক্ষেপে, স্ট্যাক এবং কিউ উভয়েরই সুবিধা এবং সীমাবদ্ধতা রয়েছে। কাজের ধরণ অনুযায়ী সঠিক ডেটা স্ট্রাকচার বেছে নিলে এই সমস্যাগুলো সহজে সমাধান করা যায়।

