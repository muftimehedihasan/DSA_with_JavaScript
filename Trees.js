// CHAPTER 15: Trees

// ট্রি হলো একটি হায়ারার্কিকাল ডেটা স্ট্রাকচার যেখানে নোড এবং এজ দিয়ে গঠিত হয়, যা প্যারেন্ট এবং চাইল্ড সম্পর্কের মাধ্যমে সংযুক্ত থাকে। ট্রিগুলি কম্পিউটার সায়েন্সে খুবই গুরুত্বপূর্ণ কারণ এগুলি ডেটা সংরক্ষণ এবং সার্চিংয়ের জন্য অত্যন্ত কার্যকর।

// এই অধ্যায়ে আমরা বিভিন্ন ধরনের ট্রি নিয়ে আলোচনা করব যেমন বাইনারি ট্রি, বাইনারি সার্চ ট্রি, এবং সেল্ফ-ব্যালেন্সিং বাইনারি সার্চ ট্রি। এছাড়াও, আমরা কীভাবে ট্রি গঠন করা হয়, কীভাবে ট্রাভার্স করা যায় এবং কিভাবে ডেটা খোঁজা যায় তা শিখব।

// ১. ট্রির মৌলিক ধারণা
// * নোড (Node): ট্রির মূল অংশ যেখানে ডেটা এবং অন্যান্য নোডের রেফারেন্স থাকে।
// * রুট নোড (Root Node): ট্রির শীর্ষ নোড যা থেকে ট্রাভার্সাল শুরু হয়।
// * এজ (Edge): নোডগুলির মধ্যে সংযোগ তৈরি করে।
// * চাইল্ড (Child): একটি নোডের অধীনস্থ নোড।
// * প্যারেন্ট (Parent): একটি নোডের উপরে থাকা নোড।
// * লিফ নোড (Leaf Node): যেসব নোডের কোন চাইল্ড নোড নেই।
// * সাবট্রি (Subtree): বড় ট্রির অংশ যা নিজেই একটি ছোট ট্রি।
// * ট্রির উচ্চতা (Height of Tree): রুট থেকে লিফ পর্যন্ত সবচেয়ে দীর্ঘ পথ।
// * নোডের গভীরতা (Depth of Node): রুট থেকে নোড পর্যন্ত এজের সংখ্যা।

// ২. ট্রির প্রকারভেদ
// ক. সাধারণ ট্রি (General Tree)
// * একটি সাধারণ ট্রিতে প্রতিটি নোডের যে কোনো সংখ্যক চাইল্ড থাকতে পারে।
// * এটি ফ্লেক্সিবল, কিন্তু বাইনারি ট্রির মতো দ্রুত সার্চিং এবং অপ্টিমাইজেশন থাকে না।

// খ. বাইনারি ট্রি (Binary Tree)
// * খ. বাইনারি ট্রি (Binary Tree)
// * পূর্ণ বাইনারি ট্রি (Full Binary Tree): প্রতিটি নোডের হয় ০ বা ২টি চাইল্ড থাকে।
// * কমপ্লিট বাইনারি ট্রি (Complete Binary Tree): সমস্ত স্তরগুলি সম্পূর্ণভাবে পূর্ণ থাকে, শুধুমাত্র শেষ স্তরে ব্যতিক্রম হতে পারে এবং বাম থেকে পূর্ণ হতে হয়।
// * পারফেক্ট বাইনারি ট্রি (Perfect Binary Tree): সব অভ্যন্তরীণ নোডের দুটি চাইল্ড থাকে এবং সমস্ত লিফ নোড একই স্তরে থাকে।

// গ. বাইনারি সার্চ ট্রি (BST)
// * একটি বাইনারি ট্রি যেখানে:
    // * বাম সাবট্রিতে শুধুমাত্র প্যারেন্টের চেয়ে ছোট মানের নোড থাকে।
    // * ডান সাবট্রিতে শুধুমাত্র প্যারেন্টের চেয়ে বড় মানের নোড থাকে।
// * উপকারিতা: দ্রুত সার্চ, ইনসার্ট এবং ডিলিট (গড়ে O(log n) সময় লাগে)।

// ঘ. সেল্ফ-ব্যালেন্সিং বাইনারি সার্চ ট্রি
// * বাইনারি সার্চ ট্রিগুলি স্বয়ংক্রিয়ভাবে ব্যালেন্স থাকে, যাতে ইনসার্ট, ডিলিট এবং সার্চ O(log n) সময়ে করা যায়।
// * উদাহরণ: এভিএল ট্রি (AVL Tree) এবং রেড-ব্ল্যাক ট্রি (Red-Black Tree)।

// ৩. ট্রি ট্রাভার্সাল (Tree Traversal)
// ট্রাভার্সাল বলতে বোঝায় ট্রির সমস্ত নোডগুলো নির্দিষ্ট ক্রমে পরিদর্শন করা। ট্রাভার্সালের প্রধান দুটি প্রকার হলো: ডেপথ-ফার্স্ট সার্চ (DFS) এবং ব্রেডথ-ফার্স্ট সার্চ (BFS)।
// ক. ডেপথ-ফার্স্ট সার্চ (DFS)
// * DFS একটি শাখা যতদূর সম্ভব অন্বেষণ করে, তারপর ব্যাকট্র্যাকিং করে। এর তিনটি সাধারণ কৌশল রয়েছে: ১. প্রি-অর্ডার ট্রাভার্সাল (Preorder Traversal): প্রথমে রুট, তারপর বাম এবং ডান সাবট্রি।
    // * ক্রম: রুট → বাম → ডান
    // * উদাহরণ: একটি ট্রি কপি করা। ২. ইন-অর্ডার ট্রাভার্সাল (Inorder Traversal): প্রথমে বাম সাবট্রি, তারপর রুট এবং শেষে ডান সাবট্রি।
    // * ক্রম: বাম → রুট → ডান
    // * উদাহরণ: BST-তে ডেটা সাজানো। ৩. পোস্ট-অর্ডার ট্রাভার্সাল (Postorder Traversal): প্রথমে বাম, তারপর ডান এবং শেষে রুট।
    // * ক্রম: বাম → ডান → রুট
    // * উদাহরণ: একটি ট্রি ডিলিট করা।

// খ. ব্রেডথ-ফার্স্ট সার্চ (BFS) / লেভেল-অর্ডার ট্রাভার্সাল (Level-Order Traversal)
    // * লেভেল অনুযায়ী নোডগুলিকে পরিদর্শন করা হয়, প্রথমে রুট থেকে শুরু করে নিচের দিকে ধীরে ধীরে এগিয়ে যাওয়া।
    // * ক্রম: প্রতিটি স্তর বাম থেকে ডান দিকে।
    // * উদাহরণ: ন্যূনতম স্তরের নোড খোঁজা।

// ৪. বাইনারি সার্চ ট্রি (BST) অপারেশন
// BST তে দ্রুত ডেটা খোঁজা, ইনসার্ট এবং ডিলিট করা যায়। এর প্রধান অপারেশনগুলি হলো:

// ক. ইনসার্ট (Insertion)
// * রুট থেকে শুরু করে বাম বা ডান দিকে সরে গিয়ে মান অনুযায়ী সঠিক স্থানে ইনসার্ট করা হয়।

// খ. সার্চ (Search)
// * রুট থেকে শুরু করে যদি মান পাওয়া যায়, তবে তা ফেরত দেয়, নাহলে বাম বা ডান দিকে সরতে হয়।

// গ. ডিলিট (Deletion)
// * ডিলিট করার ক্ষেত্রে তিনটি কেস হতে পারে: ১. নোডে কোনো চাইল্ড নেই: সরিয়ে ফেলা হয়। ২. একটি চাইল্ড রয়েছে: চাইল্ড দিয়ে প্যারেন্ট নোড প্রতিস্থাপন করা হয়। ৩. দুটি চাইল্ড রয়েছে: নোডটি প্রতিস্থাপন করতে বাম সাবট্রির বৃহত্তম মান বা ডান সাবট্রির ক্ষুদ্রতম মান ব্যবহার করা হয়।

// ৫. সেল্ফ-ব্যালেন্সিং ট্রি
// ক. এভিএল ট্রি (AVL Trees)
// * এভিএল ট্রি একটি স্বয়ংক্রিয়ভাবে ব্যালেন্সিং ট্রি যেখানে প্রতিটি নোডের বাম এবং ডান সাবট্রির উচ্চতা সর্বাধিক ১-এর পার্থক্য থাকতে পারে।
// * ব্যালেন্সিং ফ্যাক্টর: বাম এবং ডান সাবট্রির উচ্চতার পার্থক্য।
// * রোটেশন (Rotation): ট্রির ভারসাম্য নষ্ট হলে, লেফট বা রাইট রোটেশন ব্যবহার করে ভারসাম্য রক্ষা করা হয়।
    // * লেফট রোটেশন: সাবট্রির রুটকে বামে সরানো হয়।
    // * রাইট রোটেশন: সাবট্রির রুটকে ডানে সরানো হয়।

// খ. রেড-ব্ল্যাক ট্রি (Red-Black Trees)
// * রেড-ব্ল্যাক ট্রি একটি সেল্ফ-ব্যালেন্সিং ট্রি যা নোডের রং (লাল বা কালো) ব্যবহার করে ব্যালেন্স রক্ষা করে।
// * রেড-ব্ল্যাক ট্রির প্রধান বৈশিষ্ট্য: ১. প্রতিটি নোড লাল বা কালো হয়। ২. রুট সবসময় কালো হয়। ৩. লাল নোডের কোনো লাল চাইল্ড থাকে না। ৪. প্রতিটি পথে সমান সংখ্যক কালো নোড থাকে।

// ৬. ট্রির ব্যবহার
// * এক্সপ্রেশন ট্রি (Expression Trees): অ্যারিথমেটিক এক্সপ্রেশনগুলো ট্রি আকারে উপস্থাপন করা হয়।
// * ট্রাই (Trie): একটি বিশেষায়িত ট্রি যেখানে স্ট্রিং বা প্রিফিক্স স্টোর করা হয়।
// * হিপ (Heap): একটি ট্রি যা প্রায়োরিটি কিউ হিসেবে ব্যবহৃত হয়।
// * ফাইল সিস্টেম হায়ারার্কি: 

// ট্রি (Tree) ডেটা স্ট্রাকচারের উদাহরণ
// ১. সাধারণ বাইনারি ট্রি (Binary Tree) উদাহরণ:
// ধরা যাক, আমরা একটি সাধারণ বাইনারি ট্রি তৈরি করছি যেখানে প্রতিটি নোডের সর্বাধিক দুটি চাইল্ড রয়েছে।
// 1
// /   \
// 2     3
// / \   / \
// 4   5 6   7

// * Root Node: ১
// * ১-এর Left Child: ২ এবং Right Child: ৩
// * ২-এর Children: ৪ (Left) এবং ৫ (Right)
// * ৩-এর Children: ৬ (Left) এবং ৭ (Right)

// ২. বাইনারি সার্চ ট্রি (BST) উদাহরণ:
// এখানে একটি বাইনারি সার্চ ট্রির উদাহরণ দেওয়া হলো যেখানে নোডগুলিকে এমনভাবে সাজানো হয় যে বাম পাশের নোডগুলো ছোট এবং ডান পাশের নোডগুলো বড়।
// 8
// /   \
// 3     10
// / \      \
// 1   6      14
// / \     /
// 4   7   13

// * রুট নোড হলো ৮।
// * ৮-এর বাম সাবট্রিতে ৩ আছে, যা ৮-এর চেয়ে ছোট, এবং ডান সাবট্রিতে ১০ আছে, যা ৮-এর চেয়ে বড়।
// * ৩-এর বাম চাইল্ড হলো ১ এবং ডান চাইল্ড হলো ৬ (যা ৩ এবং ৮-এর মধ্যবর্তী মান)।
// * ৬-এর চাইল্ডগুলো হলো ৪ এবং ৭ (যারা যথাক্রমে ৩ ও ৮-এর মধ্যে পড়ে)।
// * ১০-এর ডান চাইল্ড হলো ১৪, এবং ১৪-এর বাম চাইল্ড হলো ১৩।

// ৩. ট্রাভার্সালের উদাহরণ (DFS):
// যদি উপরের BST-এর প্রি-অর্ডার, ইন-অর্ডার এবং পোস্ট-অর্ডার ট্রাভার্সাল দেখি:
// * Preorder (Root → Left → Right): 8, 3, 1, 6, 4, 7, 10, 14, 13
// * Inorder (Left → Root → Right): 1, 3, 4, 6, 7, 8, 10, 13, 14
// * Postorder (Left → Right → Root): 1, 4, 7, 6, 3, 13, 14, 10, 8

// এই ট্রাভার্সালগুলি নোডগুলো ভিজিট করার বিভিন্ন পদ্ধতি দেখায়।

// ৪. সেল্ফ-ব্যালেন্সিং ট্রি (AVL Tree) উদাহরণ:
// যদি আমাদের একটি AVL ট্রি থাকে এবং আমরা নোড ৫ ইনসার্ট করি যেখানে ট্রি শুরুতে ছিল:
// 3
// / \
// 2   4

// ৫ ইনসার্ট করলে এটি হয়ে যাবে:
// 3
// / \
// 2   5
//   /
//  4

// এখন এই ট্রি আনব্যালেন্সড। তাই রোটেশন করে এটিকে ব্যালেন্সড করতে হবে:
// 4
// / \
// 3   5
// /
// 2
// এটি একটি রাইট রোটেশন উদাহরণ।