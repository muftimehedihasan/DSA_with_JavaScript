// CHAPTER 13: Linked Lists
// এই অধ্যায়টি লিঙ্কড লিস্টের দুটি প্রধান প্রকার নিয়ে আলোচনা করে—সিঙ্গলি লিঙ্কড লিস্ট এবং ডাবলি লিঙ্কড লিস্ট—এবং তাদের প্রধান অপারেশন যেমন ইনসারশন, ডিলিশন এবং সার্চের ওপর আলোকপাত করে। নিচে প্রতিটি প্রকারের মূল বিষয়গুলো ব্যাখ্যা করা হলো:

// সিঙ্গলি লিঙ্কড লিস্ট (Singly Linked List)
// * গঠন: প্রতিটি নোডে ডেটা এবং পরবর্তী নোডের একটি রেফারেন্স বা পয়েন্টার থাকে।
// * ইনসারশন: নতুন নোডটি লিস্টের শুরুতে যোগ করতে সময় লাগে O(1), কারণ কোনো লুপ বা ট্রাভার্সিং প্রয়োজন হয় না।
// * ডিলিশন:
    // * শীর্ষ থেকে (Head): O(1)। 
    // * মধ্যে বা মান দ্বারা মুছে ফেলা: O(n), কারণ মানটি খুঁজে পেতে পুরো লিস্টটি ট্রাভার্স করতে হয়।
// সার্চ: কোনো নির্দিষ্ট মান খুঁজতে হলে next পয়েন্টার ব্যবহার করে প্রতিটি নোড ট্রাভার্স করতে হয়, যার জন্য সময় লাগে O(n)।

// ডাবলি লিঙ্কড লিস্ট (Doubly Linked List)
// * গঠন: প্রতিটি নোডে ডেটা, পরবর্তী নোডের রেফারেন্স এবং পূর্ববর্তী নোডের রেফারেন্স থাকে।
// ইনসারশন:
    // * শীর্ষে বা টেইলে (Head/Tail): O(1)। তবে পূর্ববর্তী নোডের পয়েন্টারও আপডেট করতে হয়।
// * ডিলিশন:
    // * শীর্ষ থেকে বা টেইল থেকে: O(1)।
    // * মধ্যে বা মান দ্বারা মুছে ফেলা: O(n), কারণ সার্চ করার জন্য ট্রাভার্স করতে হয়।
// * দ্বিমুখী সার্চ (Bidirectional Search): ডাবলি লিঙ্কড লিস্টে শীর্ষ বা টেইল থেকে উভয় দিকেই ট্রাভার্স করা সম্ভব, যা সিঙ্গলি লিঙ্কড লিস্টে সম্ভব নয়। তবে সার্চিংয়ের সময় O(n) লাগে, যদিও কিছু ক্ষেত্রে এটি বেশি কার্যকর হতে পারে।

// তুলনা
// * স্পেস কমপ্লেক্সিটি: ডাবলি লিঙ্কড লিস্টে অতিরিক্ত মেমরি লাগে, কারণ প্রতিটি নোডে পূর্ববর্তী নোডের জন্যও পয়েন্টার রাখতে হয়।
// * ইনসারশন/ডিলিশন: সিঙ্গলি এবং ডাবলি লিঙ্কড লিস্টে শীর্ষে (এবং ডাবলি লিঙ্কড লিস্টে টেইল থেকেও) O(1) সময় লাগে।
// * সার্চ: উভয় ক্ষেত্রেই O(n) সময় লাগে। তবে ডাবলি লিঙ্কড লিস্টে দ্বিমুখী ট্রাভার্সের সুবিধা থাকে।

// কবে ব্যবহার করবেন
// * সিঙ্গলি লিঙ্কড লিস্ট সহজ এবং কম মেমরি লাগে। যদি শুধু সামনের দিকে ট্রাভার্স করা লাগে, এটি ব্যবহার করা ভালো।
// * ডাবলি লিঙ্কড লিস্ট অনেক বেশি সুবিধাজনক কারণ এটি দ্বিমুখী ট্রাভার্স করা যায়। যখন উভয় প্রান্ত থেকে ঘন ঘন ডিলিশন বা ইনসারশন প্রয়োজন হয়, তখন এটি বেশি কার্যকর।

// নিচে সিঙ্গলি লিঙ্কড লিস্ট এবং ডাবলি লিঙ্কড লিস্টের উদাহরণ দেওয়া হলো:

// সিঙ্গলি লিঙ্কড লিস্ট (Singly Linked List) উদাহরণ
    // 1. নোড ডিফিনিশন:
    // function SinglyLinkedListNode(data) {
    //     this.data = data;
    //     this.next = null;
    // }

    // 2. লিঙ্কড লিস্ট ডিফিনিশন:
    // function SinglyLinkedList() {
    //     this.head = null;
    //     this.size = 0;
    // }
    
    // SinglyLinkedList.prototype.isEmpty = function() {
    //     return this.size === 0;
    // };
    
    // SinglyLinkedList.prototype.insert = function(value) {
    //     if (this.head === null) {
    //         this.head = new SinglyLinkedListNode(value);
    //     } else {
    //         var temp = this.head;
    //         this.head = new SinglyLinkedListNode(value);
    //         this.head.next = temp;
    //     }
    //     this.size++;
    // };
    
    // SinglyLinkedList.prototype.remove = function(value) {
    //     var currentHead = this.head;
    //     if (currentHead && currentHead.data === value) {
    //         this.head = currentHead.next;
    //         this.size--;
    //     } else {
    //         var prev = currentHead;
    //         while (currentHead && currentHead.next) {
    //             if (currentHead.data === value) {
    //                 prev.next = currentHead.next;
    //                 this.size--;
    //                 break;
    //             }
    //             prev = currentHead;
    //             currentHead = currentHead.next;
    //         }
    //         if (currentHead && currentHead.data === value) {
    //             prev.next = null;
    //             this.size--;
    //         }
    //     }
    // };

    // 3. ব্যবহার:
    // var sll = new SinglyLinkedList();
    // sll.insert(1);   // লিঙ্কড লিস্ট: 1 -> null
    // sll.insert(12);  // লিঙ্কড লিস্ট: 12 -> 1 -> null
    // sll.insert(20);  // লিঙ্কড লিস্ট: 20 -> 12 -> 1 -> null
    // sll.remove(12);  // লিঙ্কড লিস্ট: 20 -> 1 -> null

// ডাবলি লিঙ্কড লিস্ট (Doubly Linked List) উদাহরণ
    // 1. নোড ডিফিনিশন:
    // function DoublyLinkedListNode(data) {
    //     this.data = data;
    //     this.next = null;
    //     this.prev = null;
    // }
    
    // // লিঙ্কড লিস্ট ডিফিনিশন:
    // function DoublyLinkedList() {
    //     this.head = null;
    //     this.tail = null;
    //     this.size = 0;
    // }
    
    // DoublyLinkedList.prototype.isEmpty = function() {
    //     return this.size === 0;
    // };
    
    // DoublyLinkedList.prototype.addAtFront = function(value) {
    //     if (this.head === null) {
    //         this.head = new DoublyLinkedListNode(value);
    //         this.tail = this.head;
    //     } else {
    //         var temp = new DoublyLinkedListNode(value);
    //         temp.next = this.head;
    //         this.head.prev = temp;
    //         this.head = temp;
    //     }
    //     this.size++;
    // };
    
    // DoublyLinkedList.prototype.insertAtTail = function(value) {
    //     if (this.tail === null) {
    //         this.tail = new DoublyLinkedListNode(value);
    //         this.head = this.tail;
    //     } else {
    //         var temp = new DoublyLinkedListNode(value);
    //         temp.prev = this.tail;
    //         this.tail.next = temp;
    //         this.tail = temp;
    //     }
    //     this.size++;
    // };
    
    // DoublyLinkedList.prototype.deleteAtHead = function() {
    //     if (this.head !== null) {
    //         var toReturn = this.head.data;
    //         if (this.tail === this.head) {
    //             this.head = null;
    //             this.tail = null;
    //         } else {
    //             this.head = this.head.next;
    //             this.head.prev = null;
    //         }
    //         this.size--;
    //         return toReturn;
    //     }
    // };
    
    // DoublyLinkedList.prototype.deleteAtTail = function() {
    //     if (this.tail !== null) {
    //         var toReturn = this.tail.data;
    //         if (this.tail === this.head) {
    //             this.head = null;
    //             this.tail = null;
    //         } else {
    //             this.tail = this.tail.prev;
    //             this.tail.next = null;
    //         }
    //         this.size--;
    //         return toReturn;
    //     }
    // };
    
    // 3. ব্যবহার:
    // var dll = new DoublyLinkedList();
    // dll.addAtFront(10); // লিঙ্কড লিস্ট: 10
    // dll.addAtFront(12); // লিঙ্কড লিস্ট: 12 <-> 10
    // dll.addAtFront(20); // লিঙ্কড লিস্ট: 20 <-> 12 <-> 10
    // dll.insertAtTail(30); // লিঙ্কড লিস্ট: 20 <-> 12 <-> 10 <-> 30
    // dll.deleteAtTail(); // লিঙ্কড লিস্ট: 20 <-> 12 <-> 10
    // dll.deleteAtHead(); // লিঙ্কড লিস্ট: 12 <-> 10

    // এই উদাহরণগুলোতে দেখা যায় যে ডাবলি লিঙ্কড লিস্টে নোডের পূর্ববর্তী (prev) পয়েন্টার থাকে, যা দ্বিমুখী ট্রাভার্স ও ম্যানিপুলেশন সহজ করে।

// লিঙ্কড লিস্টের সমস্যা
// লিঙ্কড লিস্ট একটি শক্তিশালী ডেটা স্ট্রাকচার হলেও এর কিছু সমস্যা ও সীমাবদ্ধতা রয়েছে। এখানে কিছু সাধারণ সমস্যা উল্লেখ করা হলো:

// ১. মেমরি ব্যবহার
// সমস্যা: প্রতিটি নোডের জন্য অতিরিক্ত মেমরি প্রয়োজন, যা পরবর্তী (এবং সম্ভবত পূর্ববর্তী) নোডের রেফারেন্স ধরে রাখে।
// প্রভাব: অ্যারের তুলনায় মেমরি খরচ বেশি হতে পারে, যেহেতু অ্যারে শুধু ডেটা সংরক্ষণ করে।

// ২. সিকোয়েনশিয়াল এক্সেস
// সমস্যা: লিঙ্কড লিস্টের মধ্যে এলিমেন্ট অ্যাক্সেস করতে হলে হেড নোড থেকে ট্রাভার্স করতে হয়। কোন এলিমেন্ট সরাসরি অ্যাক্সেস করা যায় না।
// প্রভাব: মধ্যবর্তী বা শেষের এলিমেন্ট এক্সেস করতে O(n) সময় লাগে।

// ৩. অপারেশনগুলির জটিলতা
// সমস্যা: ইনসারশন ও ডিলিশন অপারেশনের জন্য পাশের নোডগুলির পয়েন্টার আপডেট করতে হয়, যা জটিল ও ভুল হওয়া সম্ভব।
// প্রভাব: ইমপ্লিমেন্টেশন জটিল এবং বাগ হওয়ার সম্ভাবনা থাকে।

// ৪. র্যান্ডম অ্যাক্সেসের অভাব
// সমস্যা: লিঙ্কড লিস্ট র্যান্ডম অ্যাক্সেস সাপোর্ট করে না। কোনো এলিমেন্ট অ্যাক্সেস করতে হলে হেড থেকে শুরু করে ট্রাভার্স করতে হয়।
// প্রভাব: ইনডেক্স দ্বারা এলিমেন্ট অ্যাক্সেস করার মতো অপারেশনগুলি অদক্ষ হয়।

// ৫. পাল্টানোর জটিলতা
// সমস্যা: সিঙ্গলি লিঙ্কড লিস্ট রিভার্স করতে হলে পয়েন্টারের দিক পরিবর্তন করতে হয়, যা জটিল হতে পারে।
// প্রভাব: রিভার্সিং প্রক্রিয়া জটিল ও ভুল হওয়া সম্ভব।

// ৬. ফ্র্যাগমেন্টেশন ও ক্যাশ পারফরম্যান্সের অভাব
// সমস্যা: লিঙ্কড লিস্টের নোডগুলো ভিন্ন ভিন্ন মেমরি অবস্থানে থাকতে পারে, যা ক্যাশ লোকালিটি কমায়।
// প্রভাব: অ্যারের তুলনায় ধীর গতির অ্যাক্সেস সময়।

// ৭. মেমরি লিক্স ও পয়েন্টার ত্রুটি
// সমস্যা: পয়েন্টারগুলির ভুল পরিচালনা মেমরি লিক্স বা ড্যাংলিং পয়েন্টার সৃষ্টি করতে পারে।
// প্রভাব: প্রোগ্রামের ক্র্যাশ বা অপ্রত্যাশিত আচরণ ঘটতে পারে।

// ৮. ডাবল লিঙ্কড লিস্টের জটিলতা
// সমস্যা: ডাবল লিঙ্কড লিস্টে প্রতিটি নোডের জন্য দুইটি পয়েন্টার (next ও prev) রাখতে হয়, যা জটিলতা বৃদ্ধি করে।
// প্রভাব: নোড ম্যানিপুলেশনের ক্ষেত্রে বেশি জটিলতা ও ভুল হওয়ার সম্ভাবনা থাকে।

// উদাহরণ
// ১. মেমরি ব্যবহার উদাহরণ:
// যদি আপনার একটি লিঙ্কড লিস্টে ১০ লাখ নোড থাকে, প্রতিটি নোডে একটি পয়েন্টার থাকে। যদি প্রতিটি পয়েন্টার ৮ বাইট জায়গা নেয়, তাহলে পয়েন্টারের জন্য মোট মেমরি খরচ উল্লেখযোগ্য হতে পারে।

// ২. সিকোয়েনশিয়াল অ্যাক্সেস উদাহরণ:
// লিঙ্কড লিস্টে ১০০০ তম এলিমেন্ট খুঁজতে হলে আপনাকে ৯৯৯টি নোড ট্রাভার্স করতে হবে, যেখানে অ্যারে থেকে সরাসরি অ্যাক্সেস করা সম্ভব।

// ৩. ইনসারশন জটিলতা উদাহরণ:
// কোনো নোডের পরে নতুন নোড যোগ করতে হলে পূর্ববর্তী নোডের পয়েন্টার ও নতুন নোডের পয়েন্টার আপডেট করতে হয়, যা ভুল হওয়া সম্ভব।

// ৪. রিভার্সিং উদাহরণ:
// সিঙ্গলি লিঙ্কড লিস্ট রিভার্স করতে হলে প্রতিটি নোডের পয়েন্টার পরিবর্তন করতে হয়, যা জটিল ও ভুল হওয়ার সম্ভাবনা থাকে।

// সমস্যা সমাধানের কৌশল
// ১. উপযুক্ত ডেটা স্ট্রাকচার ব্যবহার করুন: র্যান্ডম অ্যাক্সেস প্রয়োজন হলে অ্যারে বা অন্যান্য ডেটা স্ট্রাকচার ব্যবহার করুন। 2. মেমরি ব্যবহার অপটিমাইজ করুন: কমপ্যাক্ট নোড রিপ্রেজেন্টেশন ব্যবহার করুন। 3. সাবলীল পরীক্ষা বাস্তবায়ন করুন: বাগ ও এজ কেসের জন্য ভালো পরীক্ষা করুন। 4. হাইব্রিড স্ট্রাকচার বিবেচনা করুন: ব্যালান্সড ট্রি বা স্কিপ লিস্ট ব্যবহার করুন যদি তারা আপনার নির্দিষ্ট প্রয়োজনের জন্য ভাল পারফরম্যান্স দেয়।