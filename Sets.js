/* Chapter 9: Sets */
// এই অধ্যায়টি সেট (Set) নিয়ে আলোচনা করে। সেটের ধারণা, তার গাণিতিক সংজ্ঞা এবং JavaScript-এ সেট কীভাবে কাজ করে তা ব্যাখ্যা করা হয়েছে। বিভিন্ন সেট অপারেশন যেমন ইনসারশন, ডিলিশন এবং ইউনিকনেস চেক কিভাবে করা হয় তা দেখানো হয়েছে। এই অধ্যায় শেষে আপনি JavaScript-এ Set অবজেক্ট ব্যবহার করে কিভাবে সেট অপারেশনগুলি কার্যকরভাবে করতে পারবেন তা শিখবেন।

// সেট (Sets) কী?
// একটি সেট হল এমন একটি ডেটা স্ট্রাকচার যেখানে আনঅর্ডারড (অবিন্যস্ত) এবং ইউনিক (অনন্য) উপাদানগুলি থাকে। অর্থাৎ, সেটে কোনো উপাদান একাধিকবার থাকতে পারে না। উদাহরণস্বরূপ, {1, 2, 3, 4} একটি সেট, যেখানে কোনো উপাদান পুনরাবৃত্তি হয়নি।

// JavaScript-এ Set অবজেক্টের মাধ্যমে সেট তৈরি করা যায়:
// let exampleSet = new Set();
// JavaScript-এর Set অবজেক্টের একটি মাত্র প্রপার্টি আছে, size, যা সেটে উপাদানগুলির সংখ্যা দেয়।

// সেট অপারেশনসমূহ
// 1. ইনসারশন (Insertion)
// add মেথড ব্যবহার করে সেটে উপাদান যোগ করা হয়। যদি উপাদানটি ইতোমধ্যে সেটে থাকে, তবে সেটি পুনরায় যোগ হয় না।
// let exampleSet = new Set();
// exampleSet.add(1); // Set {1}
// exampleSet.add(1); // Set {1} - একই উপাদান পুনরায় যোগ হয়নি
// exampleSet.add(2); // Set {1, 2}
// টাইম কমপ্লেক্সিটি: O(1)

// 2. ডিলিশন (Deletion)
// delete মেথড ব্যবহার করে সেট থেকে একটি উপাদান মুছে ফেলা যায়। এটি একটি বুলিয়ান রিটার্ন করে (true যদি উপাদানটি মুছে ফেলা হয়, অন্যথায় false)।
// let exampleSet = new Set();
// exampleSet.add(1);    // Set {1}
// exampleSet.delete(1); // true, Set {}
// টাইম কমপ্লেক্সিটি: O(1)

// 3. কন্টেইনস (Contains)
// has মেথড ব্যবহার করে চেক করা যায় যে একটি উপাদান সেটে আছে কিনা।
// let exampleSet = new Set();
// exampleSet.add(1);   // Set {1}
// exampleSet.has(1);   // true
// exampleSet.has(2);   // false

// টাইম কমপ্লেক্সিটি: O(1)

// অন্যান্য সেট অপারেশনসমূহ
// ইন্টারসেকশন (Intersection)
// দুই সেটের ইন্টারসেকশন হল সেই উপাদানগুলি যা উভয় সেটে উপস্থিত থাকে।
// function intersectSets(setA, setB) {
//     let intersection = new Set();
//     for (let elem of setB) {
//         if (setA.has(elem)) {
//             intersection.add(elem);
//         }
//     }
//     return intersection;
// }

// let setA = new Set([1, 2, 3, 4]);
// let setB = new Set([2, 3]);
// intersectSets(setA, setB); // Set {2, 3}

// সুপারসেট (Superset)
// যদি একটি সেটে অন্য একটি সেটের সমস্ত উপাদান থাকে, তাহলে সেটিকে সুপারসেট বলে।
// function isSuperset(setA, subset) {
//     for (let elem of subset) {
//         if (!setA.has(elem)) {
//             return false;
//         }
//     }
//     return true;
// }

// let setA = new Set([1, 2, 3, 4]);
// let setB = new Set([2, 3]);
// isSuperset(setA, setB); // true

// ইউনিয়ন (Union)
// দুই সেটের ইউনিয়ন হল সেই সেট যেখানে উভয় সেটের সব উপাদান থাকে, তবে কোনো ডুপ্লিকেট থাকে না।
// function unionSet(setA, setB) {
//     let union = new Set(setA);
//     for (let elem of setB) {
//         union.add(elem);
//     }
//     return union;
// }

// let setA = new Set([1, 2, 3, 4]);
// let setB = new Set([5]);
// unionSet(setA, setB); // Set {1, 2, 3, 4, 5}

// ডিফারেন্স (Difference)
// একটি সেট থেকে অন্য সেটের উপাদানগুলি বাদ দেওয়া হলে যে সেট অবশিষ্ট থাকে সেটিকে ডিফারেন্স বলে।
// function differenceSet(setA, setB) {
//     let difference = new Set(setA);
//     for (let elem of setB) {
//         difference.delete(elem);
//     }
//     return difference;
// }

// let setA = new Set([1, 2, 3, 4]);
// let setB = new Set([2, 3]);
// differenceSet(setA, setB); // Set {1, 4}

// সারাংশ
// একটি সেট হল এমন একটি ডেটা স্ট্রাকচার, যেখানে অনন্য এবং অবিন্যস্ত উপাদান থাকে।
// JavaScript-এর Set অবজেক্ট O(1) সময়ে ইনসারশন, ডিলিশন, এবং মেম্বারশিপ চেক করতে সক্ষম।
// অন্যান্য সাধারণ অপারেশনগুলির মধ্যে রয়েছে ইন্টারসেকশন, ইউনিয়ন, ডিফারেন্স, এবং সুপারসেট চেক।

// সেট ডেটা স্ট্রাকচারের সমস্যাগুলি:
// যদিও সেট (Set) ডেটা স্ট্রাকচার অনেক ক্ষেত্রে শক্তিশালী এবং কার্যকর, কিছু সীমাবদ্ধতা এবং সমস্যা রয়েছে যেগুলো ব্যবহার করার সময় বিবেচনা করতে হয়। নিচে সেট ডেটা স্ট্রাকচারের কিছু সাধারণ সমস্যা তুলে ধরা হলো:

// ১. অর্ডারের অভাব
// সমস্যা: সেট একটি অবিন্যস্ত (unordered) সংগ্রহ, অর্থাৎ উপাদানগুলো কোনো নির্দিষ্ট ক্রমানুসারে সংরক্ষিত হয় না। তাই সেগুলোকে ইনডেক্স দিয়ে অ্যাক্সেস করা যায় না, যেমনটি অ্যারে বা লিস্টের ক্ষেত্রে করা যায়।
// প্রভাব: যদি আপনার ডেটা কোনো নির্দিষ্ট ক্রমে থাকতে হয় বা যদি আপনি উপাদানগুলোকে অবস্থান অনুযায়ী দ্রুত অ্যাক্সেস করতে চান, তবে সেট উপযুক্ত নয়।

// ২. নকল উপাদান রাখা যায় না
// সমস্যা: সেটে নকল (ডুপ্লিকেট) উপাদান রাখা যায় না। যদিও এটি অনন্যতা নিশ্চিত করার জন্য ভালো, এটি সমস্যা সৃষ্টি করতে পারে যদি আপনার প্রয়োজন হয় একই উপাদান একাধিকবার সংরক্ষণ করার।
// প্রভাব: যদি আপনার ডেটায় একাধিকবার একই উপাদান থাকার প্রয়োজন হয় (যেমন মাল্টিসেট বা ব্যাগের ক্ষেত্রে), তবে সেট সরাসরি ব্যবহার করা সম্ভব নয়।

// ৩. সীমিত ব্যবহার ক্ষেত্র
// সমস্যা: সেট সাধারণত সদস্যতা যাচাই, ডুপ্লিকেট অপসারণ, এবং সেট অপারেশন (ইন্টারসেকশন, ইউনিয়ন, ডিফারেন্স) এর জন্য ব্যবহৃত হয়। তবে, এটি অন্যান্য ডেটা ম্যানিপুলেশনের ক্ষেত্রে তেমন কার্যকর নয়।
// প্রভাব: যদি আপনার অ্যাপ্লিকেশনটি জটিল ডেটা স্ট্রাকচার (যেমন সোর্টিং, ইনডেক্সিং) প্রয়োজন করে, সেট সম্ভবত দক্ষতার সাথে কাজ করবে না।

// ৪. মেমোরি ওভারহেড
// সমস্যা: সেট সাধারণত হ্যাশ টেবিল দিয়ে প্রয়োগ করা হয়, যা কিছু অতিরিক্ত মেমোরি খরচ করে। বড় ডেটা সংরক্ষণের সময় হ্যাশিং প্রক্রিয়া মেমোরি বেশি ব্যবহার করতে পারে।
// প্রভাব: মেমোরি সীমাবদ্ধতার মধ্যে কাজ করতে হলে এই অতিরিক্ত মেমোরি ব্যবহারের সমস্যা হতে পারে।

// ৫. জটিল হ্যাশিং অপারেশন
// সমস্যা: সেটের উপর নির্ভর করে হ্যাশিং অপারেশনের জন্য, যদি হ্যাশ ফাংশনটি দুর্বল হয় বা অনেক হ্যাশ সংঘর্ষ হয় (যখন বিভিন্ন উপাদান একই হ্যাশ মান তৈরি করে), তখন কার্যকারিতা কমে যেতে পারে।
// প্রভাব: হ্যাশ সংঘর্ষ হলে সেটের কার্যকারিতা কমে যেতে পারে, ফলে অপারেশনগুলো ধীরগতিতে হতে পারে।

// ৬. পরিবর্তনযোগ্য উপাদান সংরক্ষণ করা যায় না
// সমস্যা: অনেক প্রোগ্রামিং ভাষায়, সেটে mutable (পরিবর্তনযোগ্য) উপাদান সংরক্ষণ করা যায় না, কারণ এগুলো পরিবর্তন হতে পারে, যা সেটের অনন্যতার গুণাবলী ভেঙে দিতে পারে।
// প্রভাব: যদি আপনার অ্যাপ্লিকেশনে mutable ডেটা সংরক্ষণ করতে হয়, তাহলে সেগুলোকে immutable রূপান্তর করে সেটে ঢোকাতে হবে।

// ৭. অন্যান্য ডেটা স্ট্রাকচারের তুলনায় সীমিত অপারেশন
// সমস্যা: সেট অ্যারে বা লিস্টের মতো নির্দিষ্ট অপারেশনগুলো সমর্থন করে না, যেমন slicing বা কোনো নির্দিষ্ট অবস্থানে উপাদান যোগ করা।
// প্রভাব: যদি আপনার অ্যাপ্লিকেশনে এমন ধরনের অপারেশন প্রয়োজন হয়, সেক্ষেত্রে সেট ব্যবহার করা সীমাবদ্ধ এবং অকার্যকর হতে পারে।

// ৮. অন্যান্য ডেটা স্ট্রাকচার থেকে রূপান্তরের খরচ
// সমস্যা: বড় লিস্ট বা অ্যারেকে সেটে রূপান্তর করা কখনও কখনও সময়সাপেক্ষ (O(n) সময় জটিলতা) এবং এটি কর্মক্ষমতায় প্রভাব ফেলতে পারে।
// প্রভাব: যদি প্রায়ই ডেটা স্ট্রাকচারের মধ্যে রূপান্তর প্রয়োজন হয়, এটি পারফরম্যান্সের উপর প্রভাব ফেলতে পারে।

// ৯. সেটে উপাদান পুনরাবৃত্তি ধীর হতে পারে
// সমস্যা: সেটে উপাদান পুনরাবৃত্তি করার সময় (যেমন সব উপাদান বের করা), সময় জটিলতা O(n), যা কিছু অন্যান্য ডেটা স্ট্রাকচারের তুলনায় ধীর।
// প্রভাব: যদি আপনার অ্যাপ্লিকেশন বড় ডেটার উপর বারবার পুনরাবৃত্তি প্রয়োজন হয়, তাহলে এটি একটি সীমাবদ্ধতা হতে পারে।

// ১০. জটিল ডেটার সাবসেট পরিচালনা করা কঠিন
// সমস্যা: জটিল ডেটা টাইপ (যেমন বড় tuple বা nested data structure) সেটে সঠিকভাবে ব্যবহারের ক্ষেত্রে সমস্যা দেখা দিতে পারে।
// প্রভাব: এই কারণে গ্রাফ বা বহু-মাত্রিক ডেটাসেটের মতো উন্নত অ্যালগরিদম প্রয়োগ করা চ্যালেঞ্জিং হতে পারে।

// সংক্ষেপে, সেট ডেটা স্ট্রাকচার অনন্যতা পরীক্ষা এবং দ্রুত সদস্যতা যাচাইয়ের জন্য কার্যকর, তবে এর সীমাবদ্ধতাগুলি তখন প্রকট হয় যখন ক্রমযুক্ত সংগ্রহ বা জটিল ডেটা ম্যানিপুলেশন প্রয়োজন হয়।

// সেটের বিকল্প কী?
// সেটের বিকল্প হিসেবে বিভিন্ন ডেটা স্ট্রাকচার ব্যবহার করা যেতে পারে, নির্ভর করে আপনি কোন ধরনের কাজ করতে চান। এখানে কিছু বিকল্প এবং তাদের ব্যবহার তুলে ধরা হলো:

// ১. অ্যারে/লিস্ট (Array/List)
// বৈশিষ্ট্য: অ্যারে বা লিস্ট হল ক্রমযুক্ত (ordered) ডেটা স্ট্রাকচার যেখানে উপাদানগুলো ইনডেক্স ব্যবহার করে সংরক্ষণ করা হয়।
// কখন ব্যবহার করবেন: যদি আপনাকে ক্রম অনুযায়ী উপাদান সংরক্ষণ করতে হয় এবং ডুপ্লিকেট উপাদান মঞ্জুর হয়, তবে লিস্ট ব্যবহার করা যেতে পারে।
// সীমাবদ্ধতা: ডুপ্লিকেট উপাদান স্বয়ংক্রিয়ভাবে ফিল্টার হয় না, এবং বড় ডেটার ক্ষেত্রে অনুসন্ধান, সংযোজন বা অপসারণের সময় জটিলতা বেশি (O(n)) হতে পারে।

// ২. ম্যাপ/অবজেক্ট (Map/Object)
// বৈশিষ্ট্য: ম্যাপ বা অবজেক্ট হলো key-value পেয়ার সংরক্ষণের জন্য ব্যবহৃত ডেটা স্ট্রাকচার। JavaScript-এ সেটের মতো ম্যাপেও দ্রুত অনুসন্ধান করা যায়।
// কখন ব্যবহার করবেন: যদি আপনার উপাদানগুলোর সাথে কোনো মান (value) সংযুক্ত করতে হয় এবং দ্রুত অ্যাক্সেস ও আপডেটের প্রয়োজন হয়।
// সীমাবদ্ধতা: ম্যাপে ডুপ্লিকেট key থাকা যায় না, তবে মানগুলো ডুপ্লিকেট হতে পারে।

// ৩. হ্যাশ টেবিল (Hash Table)
// বৈশিষ্ট্য: হ্যাশ টেবিল হল একটি ডেটা স্ট্রাকচার যা হ্যাশ ফাংশনের মাধ্যমে উপাদানগুলোকে সংরক্ষণ এবং দ্রুত অনুসন্ধান করতে দেয়।
// কখন ব্যবহার করবেন: দ্রুত অনুসন্ধান এবং অনন্য উপাদান ব্যবহারের জন্য হ্যাশ টেবিল সেটের মতো কার্যকর।
// সীমাবদ্ধতা: হ্যাশ সংঘর্ষ হতে পারে এবং হ্যাশ টেবিলের কর্মক্ষমতা নির্ভর করে হ্যাশ ফাংশনের উপর।

// ৪. বাইনারি সার্চ ট্রি (Binary Search Tree)
// বৈশিষ্ট্য: বাইনারি সার্চ ট্রি একটি ক্রমযুক্ত ডেটা স্ট্রাকচার যেখানে উপাদানগুলো তুলনা করে সঠিক ক্রমে রাখা হয়।
// কখন ব্যবহার করবেন: যদি ক্রম অনুসারে উপাদানগুলো সাজানো এবং দ্রুত অনুসন্ধান, সংযোজন, বা মুছে ফেলা প্রয়োজন হয় (O(log n) সময় জটিলতা)।
// সীমাবদ্ধতা: ব্যালেন্সড না হলে সময় জটিলতা O(n) হয়ে যেতে পারে।

// ৫. বাইনারি হিপ (Binary Heap)
// বৈশিষ্ট্য: বাইনারি হিপ একটি ডেটা স্ট্রাকচার যা সর্বোচ্চ বা সর্বনিম্ন মানের উপাদান দ্রুত খুঁজে বের করতে সহায়ক।
// কখন ব্যবহার করবেন: যদি আপনাকে সর্বোচ্চ বা সর্বনিম্ন মান দ্রুত খুঁজতে হয় এবং অর্ডারিং গুরুত্বপূর্ণ নয়।
// সীমাবদ্ধতা: বাইনারি হিপ সরাসরি সার্বজনীন অনুসন্ধান বা ক্রমযুক্ত তালিকা পরিচালনা করতে অক্ষম।

// ৬. ব্লুম ফিল্টার (Bloom Filter)
// বৈশিষ্ট্য: ব্লুম ফিল্টার হল একটি প্রোবাবিলিস্টিক ডেটা স্ট্রাকচার যা মনে রাখে কোনো উপাদান সেটে আছে কিনা, কিন্তু কখনো কখনো ভুলভাবে বলে দিতে পারে যে একটি উপাদান আছে, যদিও তা নেই (false positives হতে পারে)।
// কখন ব্যবহার করবেন: যখন আপনাকে খুব দ্রুত এবং কম মেমোরিতে সদস্যতা যাচাই করতে হবে, এবং সঠিকতা ততটা গুরুত্বপূর্ণ নয়।
// সীমাবদ্ধতা: ডেটা মুছে ফেলা যায় না এবং false positives সমস্যা সৃষ্টি করতে পারে।

// ৭. ট্রাই (Trie)
// বৈশিষ্ট্য: ট্রাই একটি বিশেষ ধরনের গাছের মতো ডেটা স্ট্রাকচার, যা সাধারণত স্ট্রিং ডেটা সংরক্ষণ ও অনুসন্ধানের জন্য ব্যবহৃত হয়।
// // কখন ব্যবহার করবেন: যখন স্ট্রিং বা সিকোয়েন্সের উপর দ্রুত প্রিফিক্স অনুসন্ধান করতে হয়।
// সীমাবদ্ধতা: মেমোরি বেশি খরচ হতে পারে এবং উপাদানগুলো তুলনামূলকভাবে কম কমপ্যাক্ট হয়।

// সারসংক্ষেপ
// সেট ব্যবহার করা হয় যখন আপনার উপাদানগুলো অনন্য হতে হবে এবং অর্ডার গুরুত্বপূর্ণ নয়।
// যদি অর্ডার এবং ডুপ্লিকেট মঞ্জুরযোগ্য হয়, তবে অ্যারে/লিস্ট ভালো বিকল্প।
// যদি key-value পেয়ার ব্যবহারের প্রয়োজন হয়, তবে ম্যাপ/অবজেক্ট ব্যবহার করা যেতে পারে।
// দ্রুত অনুসন্ধান এবং সংযোজনের জন্য হ্যাশ টেবিল কার্যকর, এবং ক্রমযুক্ত উপাদান ব্যবস্থাপনার জন্য বাইনারি সার্চ ট্রি বা হিপ উপযোগী হতে পারে।

// এগুলো পরিস্থিতি অনুযায়ী নির্বাচন করতে হবে।