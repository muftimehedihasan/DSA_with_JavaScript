// অধ্যায় ১০: অনুসন্ধান এবং বাছাই (Searching and Sorting)
// অনুসন্ধান (Searching) এবং বাছাই (Sorting) হল কম্পিউটার বিজ্ঞানের গুরুত্বপূর্ণ অ্যালগরিদম। অনুসন্ধান বলতে বোঝায় একটি ডেটা স্ট্রাকচারের ভেতরে থাকা নির্দিষ্ট উপাদান খোঁজা। বাছাই বলতে বোঝায় ডেটা স্ট্রাকচারের উপাদানগুলোকে নির্দিষ্ট ক্রমানুসারে সাজানো। বিভিন্ন ডেটা স্ট্রাকচারের জন্য অনুসন্ধান এবং বাছাইয়ের অ্যালগরিদম ভিন্ন হয়, তবে এখানে অ্যারের (array) জন্য অনুসন্ধান ও বাছাইয়ের অ্যালগরিদম নিয়ে আলোচনা করা হয়েছে।

// অনুসন্ধান (Searching):
// অনুসন্ধান হলো নির্দিষ্ট উপাদান খুঁজে বের করার প্রক্রিয়া। অ্যারে থেকে অনুসন্ধানের জন্য দুই ধরনের প্রধান পদ্ধতি রয়েছে—লিনিয়ার অনুসন্ধান (Linear Search) এবং বাইনারি অনুসন্ধান (Binary Search)।

// লিনিয়ার অনুসন্ধান (Linear Search):
// লিনিয়ার অনুসন্ধান একে একে প্রতিটি উপাদান পরীক্ষা করে। এটি যত sorted (বাছাই করা) বা unsorted (বাছাই না করা) ডেটার জন্যই কাজ করতে পারে। এর সময়ের জটিলতা O(n), অর্থাৎ এটি পুরো অ্যারের প্রতিটি উপাদান পরীক্ষা করে, তাই ন্যূনতম n সংখ্যক ধাপ প্রয়োজন হয়।
// উদাহরণ:
// function linearSearch(array, n){
//     for (let i = 0; i < array.length; i++) {
//         if (array[i] == n) {
//             return true;
//         }
//     }
//     return false;
// }
// console.log(linearSearch([1, 2, 3, 4, 5], 4)); // true
// console.log(linearSearch([1, 2, 3, 4, 5], 6)); // false

// বাইনারি অনুসন্ধান (Binary Search):
// বাইনারি অনুসন্ধান sorted (বাছাই করা) অ্যারের জন্য ব্যবহৃত হয়। এটি অ্যারের মধ্যবর্তী উপাদানটি প্রথমে পরীক্ষা করে এবং তারপর নির্ধারণ করে অনুসন্ধানটি বাকি অংশের কোন অংশে চালানো উচিত। এটি O(log n) সময়ে কাজ করে, অর্থাৎ এটি প্রতি ধাপে অ্যারের আকার অর্ধেক করে।

// function binarySearch (array, n) {
//     let low = o, high = array.length - 1;
//     while (low <= high) {
//         let mid = Math.floor((low + high) / 2);
//         if (array[mid] == n){
//             return mid;
//         } else if (array[mid] < n) {
//             low = mid + 1;
//         } else {
//             high = mid - 1;
//         }
//     }
//     return -1;
// }
// console.log(binarySearch([1, 2, 3, 4, 5], 4)); // 3
// console.log(binarySearch([1, 2, 3, 4, 5,], 6)) // -1

// বাছাই (Sorting):
// বাছাই ডেটাকে একটি নির্দিষ্ট ক্রমে সাজানো হয়। কিছু সাধারণ বাছাই পদ্ধতি হলো বুদ্বুদ বাছাই (Bubble Sort), নির্বাচন বাছাই (Selection Sort), সন্নিবেশ বাছাই (Insertion Sort), কুইকসোর্ট (Quicksort), এবং মার্জসোর্ট (Mergesort)।

// বুদ্বুদ বাছাই (Bubble Sort):
// বুদ্বুদ বাছাই হলো সবচেয়ে সহজ কিন্তু সময় সাপেক্ষ বাছাই পদ্ধতি। এটি প্রতি ধাপে পার্শ্ববর্তী উপাদানগুলো তুলনা করে এবং প্রয়োজনে তাদের বিনিময় করে।
// function bubbleSort(array) {
//     for (var i = 0; i < array.length; i++) {
//       for (var j = 0; j < array.length - i - 1; j++) {
//         if (array[j] > array[j + 1]) {
//           var temp = array[j];
//           array[j] = array[j + 1];
//           array[j + 1] = temp;
//         }
//       }
//     }
//     return array;
//   }
//   console.log(bubbleSort([5, 2, 9, 1, 5, 6])); // [1, 2, 5, 5, 6, 9]
  
// নির্বাচন বাছাই (Selection Sort):
// নির্বাচন বাছাই ছোটতম উপাদানটি খুঁজে বের করে এবং সেটি প্রথম অবস্থানে রাখে। তারপর দ্বিতীয়, তৃতীয় এভাবে পুরো অ্যারে বাছাই করে।
// function selectionSort(array) {
//     for (var i = 0; i < array.length; i++) {
//       var minIndex = i;
//       for (var j = i + 1; j < array.length; j++) {
//         if (array[j] < array[minIndex]) {
//           minIndex = j;
//         }
//       }
//       if (minIndex !== i) {
//         var temp = array[i];
//         array[i] = array[minIndex];
//         array[minIndex] = temp;
//       }
//     }
//     return array;
//   }
//   console.log(selectionSort([29, 10, 14, 37, 14])); // [10, 14, 14, 29, 37]
  
// এই অধ্যায়ে অনুসন্ধান এবং বাছাইয়ের মূল কৌশলগুলোর ব্যাখ্যা দেয়া হয়েছে, যা ডেটা পরিচালনার গুরুত্বপূর্ণ অংশ।



// অনুসন্ধান (Searching) এবং বাছাই (Sorting) অ্যালগরিদমগুলির বিভিন্ন সীমাবদ্ধতা এবং সমস্যা রয়েছে, যা কখনও কখনও তাদের কার্যকারিতা কমিয়ে দেয়। নিচে বিভিন্ন সমস্যা উল্লেখ করা হলো:

// অনুসন্ধানের (Searching) সমস্যাগুলো:

// 1. লিনিয়ার অনুসন্ধানের সমস্যা:
// ধীরগতি: লিনিয়ার অনুসন্ধান O(n) সময়ের জটিলতা নিয়ে কাজ করে, যেখানে n হলো ডেটার আকার। বড় ডেটা সেটের জন্য এটি ধীর গতির হয় কারণ প্রতিটি উপাদান একে একে পরীক্ষা করতে হয়।
// অবশেষ সর্বোচ্চ সময়: সবচেয়ে খারাপ ক্ষেত্রে (যেমন শেষ উপাদান বা উপাদান না থাকলে) প্রতিটি উপাদান পরীক্ষা করতে হয়, যা কর্মক্ষমতা কমায়।

// 2. বাইনারি অনুসন্ধানের সমস্যা:
// শর্তসাপেক্ষ কাজ: বাইনারি অনুসন্ধান শুধুমাত্র বাছাই করা ডেটার উপর কার্যকরী, অর্থাৎ অ্যারে বা ডেটা আগে থেকে sorted (সাজানো) থাকতে হবে। অ-বাছাই করা ডেটার জন্য এটি ব্যবহার করা যায় না।
// বাছাইয়ের প্রয়োজন: ডেটা আগে থেকে না বাছাই করা থাকলে প্রথমে তা বাছাই করতে হবে, যা অতিরিক্ত O(n log n) সময় ব্যয় করে।

// 3. মেমরি ব্যবহারের সীমাবদ্ধতা: কিছু অনুসন্ধান অ্যালগরিদম অতিরিক্ত মেমরি ব্যবহার করে, যেমন হ্যাশ টেবিলের জন্য অতিরিক্ত স্থান প্রয়োজন হতে পারে।

// অ্যাডাপটিভিটি নেই: লিনিয়ার অনুসন্ধান বা সাধারণ বাইনারি অনুসন্ধান কোনোভাবে ডেটার বৈশিষ্ট্যকে খাপ খাওয়াতে পারে না। যদি ডেটা আংশিকভাবে বাছাই করা হয় বা বিশেষ কোনো প্যাটার্ন থাকে, অ্যালগরিদমগুলি তা কাজে লাগাতে পারে না।

// বাছাইয়ের (Sorting) সমস্যাগুলো:
// 1. বুদ্বুদ বাছাইয়ের সমস্যা:
// অকার্যকর: বুদ্বুদ বাছাই O(n²) সময় জটিলতার অধীনে কাজ করে। এটি ছোট ডেটা সেটের জন্য কার্যকর হতে পারে, তবে বড় ডেটা সেটের ক্ষেত্রে খুব ধীর।
// বাড়তি বিনিময়: এটি প্রতিটি উপাদান একাধিকবার বিনিময় করে, যা প্রয়োজনের তুলনায় বেশি কাজ করতে পারে।

// 2. নির্বাচন বাছাইয়ের সমস্যা:
// অধিক সময় খরচ: নির্বাচন বাছাইয়েরও O(n²) সময় জটিলতা রয়েছে। প্রতিটি উপাদানের জন্য বাকি উপাদানগুলোর সাথে তুলনা করতে হয়, যা বড় ডেটার জন্য ধীর।
// অ্যাডাপটিভ নয়: নির্বাচনের ক্ষেত্রে আংশিকভাবে বাছাই করা ডেটার ক্ষেত্রে তেমন কোনো উপকার হয় না, অর্থাৎ সব ধরনের ডেটার জন্য একই পদ্ধতি অনুসরণ করতে হয়।

// 3. কুইকসোর্টের সমস্যা:
// সর্বোচ্চ ক্ষেত্রে ধীর: যদি সবচেয়ে খারাপ অবস্থার সম্মুখীন হয়, যেমন যদি প্রতিটি পিভট সবচেয়ে ছোট বা সবচেয়ে বড় হয়, তাহলে কুইকসোর্ট O(n²) সময়ে পরিণত হয়।
// স্থায়ীত্বের সমস্যা: কুইকসোর্ট সাধারণত স্থিতিশীল নয়, অর্থাৎ সমান মানের উপাদানগুলো বাছাইয়ের পরে তাদের পূর্বের অবস্থান ধরে রাখতে পারে না।

// 4. মার্জসোর্টের সমস্যা:
// বাড়তি স্থান প্রয়োজন: মার্জসোর্ট অতিরিক্ত স্থান ব্যবহার করে, কারণ এটি সাধারণত একটি সহায়ক অ্যারের প্রয়োজন করে। ফলে বড় ডেটা সেটের জন্য বেশি মেমরি প্রয়োজন।
// কাঠামোগত জটিলতা: মার্জসোর্ট কাঠামোগতভাবে জটিল হতে পারে এবং এর কার্যকারিতা ও বাস্তবায়ন কিছুটা কঠিন।

// 5. ইনপ্লেস নয়: অনেক বাছাই পদ্ধতি (যেমন মার্জসোর্ট) ইনপ্লেস নয়, অর্থাৎ এটি মূল ডেটার উপর পরিবর্তন না করে নতুন স্থান ব্যবহার করে ডেটা বাছাই করে।

// সাধারণ সমস্যা:
// ডেটার বৈচিত্র্য: বিভিন্ন ধরনের ডেটার ক্ষেত্রে এক অ্যালগরিদম থেকে অন্যটি কার্যকরী হতে পারে না। যেমন, বৃহত্তর ডেটার ক্ষেত্রে ধীর অ্যালগরিদম যেমন বুদ্বুদ বাছাই ব্যবহার করা উচিত নয়।
// অ্যালগরিদমের নির্বাচন: নির্দিষ্ট পরিস্থিতিতে কোন অ্যালগরিদমটি সবচেয়ে কার্যকর হবে তা সঠিকভাবে নির্ধারণ করা প্রয়োজন, নাহলে কর্মক্ষমতার সমস্যা দেখা দিতে পারে।

// উপসংহার:
// অনুসন্ধান এবং বাছাই অ্যালগরিদমের জন্য এই সমস্যাগুলো বুঝে এবং নির্দিষ্ট ডেটা স্ট্রাকচার এবং প্রয়োজনের ভিত্তিতে উপযুক্ত অ্যালগরিদম নির্বাচন করলে কার্যকারিতা অনেক বেশি উন্নত করা যায়।

// কোন অ্যালগরিদম ভালো?
// অনুসন্ধান এবং বাছাই অ্যালগরিদমের ক্ষেত্রে "ভালো" বা "সেরা" অ্যালগরিদম নির্ভর করে নির্দিষ্ট পরিস্থিতি, ডেটার ধরন, এবং আপনার প্রয়োজনীয়তার উপর। কোনো একক অ্যালগরিদম সব পরিস্থিতির জন্য সেরা নয়। তবে কিছু সাধারণ উপাদান যা একটি অ্যালগরিদম ভালো কিনা তা নির্ধারণ করতে সাহায্য করে, তা হলো:
// সময়ের জটিলতা (Time Complexity): অ্যালগরিদম কত দ্রুত কাজ করে।
// মেমরির ব্যবহার (Space Complexity): অ্যালগরিদম কতটা মেমরি বা স্থান ব্যবহার করে।
// সহজতা (Ease of Implementation): অ্যালগরিদমটি বাস্তবায়নে কতটা সহজ বা জটিল।
// স্থিতিশীলতা (Stability): সমান মানের উপাদানগুলির পূর্বের অবস্থান অ্যালগরিদম শেষে থাকে কিনা।

// বাছাইয়ের জন্য ভালো অ্যালগরিদম:
// ১. মার্জসোর্ট (Merge Sort):
// সময়ের জটিলতা: O(n log n)।
// মেমরির জটিলতা: O(n) (অতিরিক্ত স্থান প্রয়োজন)।
// স্থিতিশীল: হ্যাঁ।
// কখন ভালো? যদি ডেটা বড় হয় এবং স্থিতিশীলতা প্রয়োজন হয়, তবে মার্জসোর্ট ভালো। এটি বড় আকারের ডেটা সেটের জন্য কার্যকর এবং সর্বদা O(n log n) সময় নেয়।

// ২. কুইকসোর্ট (Quick Sort):
// সময়ের জটিলতা: গড়ে O(n log n), কিন্তু খারাপ ক্ষেত্রে O(n²)।
// মেমরির জটিলতা: O(log n)।
// স্থিতিশীল: না।
// কখন ভালো? ছোট বা মাঝারি আকারের ডেটা সেটের জন্য কুইকসোর্ট অনেক দ্রুত এবং ইনপ্লেস কাজ করে, অর্থাৎ অতিরিক্ত মেমরি ব্যবহার করে না। তবে সবচেয়ে খারাপ ক্ষেত্রে O(n²) সময় লাগে, তাই worst-case optimization প্রয়োজন হলে সাবধান থাকতে হবে।

// ৩. হিপসোর্ট (Heap Sort):
// সময়ের জটিলতা: O(n log n)।
// মেমরির জটিলতা: O(1) (ইনপ্লেস)।
// স্থিতিশীল: না।
// কখন ভালো? হিপসোর্ট ইনপ্লেস কাজ করে এবং O(n log n) সময়ের মধ্যে কাজ করে। এটি তখন ভালো, যখন আপনি অতিরিক্ত স্থান ব্যবহার করতে না চান।

// ৪. ইনসারশন সোর্ট (Insertion Sort):
// সময়ের জটিলতা: O(n²)।
// স্থিতিশীল: হ্যাঁ।
// কখন ভালো? ছোট আকারের বা প্রায় বাছাই করা (nearly sorted) ডেটার ক্ষেত্রে ইনসারশন সোর্ট খুব কার্যকর। যদিও O(n²) সময় লাগে, প্রায়-বাছাই করা ডেটার ক্ষেত্রে এটি প্রায় O(n) পর্যন্ত উন্নতি করে।

// অনুসন্ধানের জন্য ভালো অ্যালগরিদম:
// ১. বাইনারি অনুসন্ধান (Binary Search):
// সময়ের জটিলতা: O(log n)।
// কখন ভালো? যদি ডেটা পূর্বে থেকেই বাছাই করা থাকে, বাইনারি অনুসন্ধান খুব দ্রুত। এটি বড় ডেটাসেটের জন্য খুব কার্যকর, কিন্তু অ-বাছাই করা ডেটার ক্ষেত্রে কাজ করে না।

// ২. হ্যাশ টেবিল অনুসন্ধান (Hash Table Search):
// সময়ের জটিলতা: গড়ে O(1)।
// কখন ভালো? যদি ডেটা ইনডেক্স করতে হয় এবং তা খুব দ্রুত খুঁজে পেতে হয়, তবে হ্যাশ টেবিলের ভিত্তিতে অনুসন্ধান খুব ভালো। এটি কেবলমাত্র নির্দিষ্ট শর্তে কাজ করে, যেমন ডেটার কোনো পুনরাবৃত্তি না থাকা এবং ভালো হ্যাশ ফাংশন থাকা।

// ৩. লিনিয়ার অনুসন্ধান (Linear Search):
// সময়ের জটিলতা: O(n)।
// কখন ভালো? ছোট ডেটাসেটের জন্য বা যদি ডেটা পূর্বে থেকে বাছাই করা না থাকে। এটি খুব সহজ, কিন্তু বড় ডেটার ক্ষেত্রে ধীর।

// উপসংহার:
// বড় ডেটার জন্য এবং সর্বোচ্চ কার্যকারিতা চাওয়া হলে কুইকসোর্ট, মার্জসোর্ট, অথবা হিপসোর্ট ভালো বাছাই পদ্ধতি।
// ছোট ডেটার জন্য ইনসারশন সোর্ট ভালো, বিশেষত যদি ডেটা প্রায় বাছাই করা থাকে।
// অনুসন্ধানের জন্য বাইনারি অনুসন্ধান দ্রুত, তবে হ্যাশ টেবিলের ভিত্তিতে অনুসন্ধান খুব দ্রুত হতে পারে যদি সঠিক পরিস্থিতি থাকে।

// অতএব, আপনার ডেটা এবং প্রয়োজন অনুযায়ী কোন অ্যালগরিদম ভালো তা নির্ধারণ করতে হবে।